<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>15618 Final Project: Parallel MST Algorithms on Dynamic Graphs</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #fff;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        h1, h2, h3 {
            color: #333;
        }

        code {
            font-family: Consolas, monospace;
            background-color: #f0f0f0;
            padding: 2px 4px;
            border-radius: 4px;
        }

        pre {
            background-color: #f0f0f0;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>15618 Final Project: Parallel MST Algorithms on Dynamic Graphs</h1>
        <p>This repository contains tools and implementations for exploring and testing different Minimum Spanning Tree (MST) algorithms. It includes a Python script to generate random connected Watts Strogatz graphs and a C++ program to compute MSTs using various algorithms.</p>

        <h2>The Minimum Spanning Tree Problem</h2>
        <p>The Minimum Spanning Tree (MST) problem is a fundamental problem in computer science and has numerous applications in various fields, including computer networking, circuit design, and transportation systems. Given a connected, weighted graph, the goal is to find a subset of edges that form a tree spanning all vertices and has the minimum total weight.</p>
        <p>MSTs are useful in scenarios where it is necessary to connect a set of points with minimum cost while ensuring connectivity. For example, in computer networks, MSTs can be used to find the most efficient way to connect various nodes while minimizing the cost of cables or wireless links. In transportation systems, MSTs can help determine the most cost-effective routes for constructing roads or railways while connecting all cities or locations.</p>

        <h2>Supported Algorithms</h2>
        <ul>
            <li>Kruskal's Algorithm</li>
            <li>Prim's Algorithm</li>
            <li>Boruvka's Algorithm</li>
            <li>Parallel Boruvka's Algorithm</li>
            <li>Sequential MST Update on New Edges</li>
        </ul>

        <h2>Prerequisites</h2>
        <p>Ensure you have Python 3 and a C++ compiler installed on your system. This project also requires <code>make</code> for building the C++ code.</p>

        <h2>Generating Graphs</h2>
        <p>The script <code>generate_graph.py</code> is used to generate random connected Watts Strogatz graphs. Here's how you can use it:</p>

        <h3>Usage</h3>
        <pre><code>python3 generate_graph.py -n &lt;number_of_nodes&gt; -k &lt;nearest_neighbors&gt; -p &lt;rewiring_prob&gt; -f &lt;output_file&gt;</code></pre>
        <ul>
            <li><code>-n</code>: Number of nodes in the graph.</li>
            <li><code>-k</code>: Each node is joined with its k nearest neighbors in a ring topology.</li>
            <li><code>-p</code>: The probability of rewiring each edge.</li>
            <li><code>-f</code>: Output file name, which follows the naming convention graph_i.txt, where i indicates that the graph contains 10^i nodes.</li>
        </ul>

        <h3>Example</h3>
        <pre><code>python3 generate_graph.py -n 100000 -k 100 -p 0.3 -f graph_5.txt</code></pre>

        <h2>Building and Running the MST Algorithms</h2>
        <p>To compile the MST implementation, use the included Makefile:</p>
        <pre><code>make</code></pre>
        <p>After building the project, you can run the MST algorithms using:</p>
        <pre><code>./mst -s &lt;size&gt; -t &lt;num_threads&gt;</code></pre>
        <ul>
            <li><code>-s</code>: Specifies the size of the graph as an exponent of 10. For example, -s 5 means the graph size is 10^5 and the program will read from graph_5.txt.</li>
            <li><code>-t</code>: Specifies the number of threads to use in the Parallel Boruvka's algorithm.</li>
        </ul>
        <p>For now, this command will execute Kruskal's, Prim's, Boruvka's, and Parallel Boruvka's algorithms on the graph described in graph_&lt;size&gt;.txt, outputting the runtimes and total weights of the MSTs generated (the total weights should match).</p>

        <h2>Running the Dynamic MST Algorithms</h2>
        <p>You can run the Sequential MST Update on New Edges using:</p>
        <pre><code>./dynamic -s &lt;size&gt;</code></pre>
        <ul>
            <li><code>-s</code>: Specifies the size of the graph as an exponent of 10. For example, -s 3 means the graph size is 10^3 and the program will read from graph_3.txt.</li>
        </ul>
        <p>The program shuffles the edges and partition them by 0.95 vs 0.05 ratio. We use the sequential Kruskal's algorithm to generate an MST using the first 95% of the edges, and add the remaining 5% using our MST update algorithm.</p>
        <p>The MST update algorithm is based on the following:</p>
        <ul>
            <li>Edges that are not in the existing MST will not be in the new MST.</li>
            <li>The newly added edge creates exactly one cycle if added to the existing MST.</li>
            <li>We remove the heaviest edge from that cycle</li>
        </ul>
        <p>However, since this is the first draft of our implementation, the code is not optimized may be slow.</p>

        <h2>Project Plan</h2>
        <p>So far, we have implemented sequential versions of Kruskal's, Prim's, and Boruvka's algorithms, as well as parallel versions of these algorithms using OpenMP. We have particularly focused on optimizing the parallel implementation of Boruvka's algorithm and have achieved significant speedups compared to the sequential version.</p>
        <p>For the next two weeks, our plan is as follows:</p>
        <ul>
            <li><strong>Week 1:</strong> Finalize the parallel implementation for the dynamic update of the MST. This remains a complex aspect that requires further research and development.</li>
            <li><strong>Week 2:</strong> Conduct extensive benchmarking experiments to evaluate the performance and scalability of both our existing and potentially dynamic parallel algorithms. Additionally, we will perform a comparative analysis between the sequential and parallel implementations, focusing on the performance impact and solution quality.</li>
        </ul>
        <p>By the end of these two weeks, we aim to have a robust and optimized parallel solution for the dynamic aspects of the MST algorithms, as well as comprehensive benchmarking results and analysis to demonstrate the benefits of our parallel approaches.</p>
    </div>
</body>
</html>